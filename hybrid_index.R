############## hybrid map and correlation analysis ########################
# use hybrid index generated by Pascal

hi<-read.table("/Users/piyalkaru/Desktop/UPP/RUS_CLIN/out/hybrids_pascal/hybrid_pop.txt",h=T)

# 1. comparison with pi
pi<-read.table("/Users/piyalkaru/Desktop/UPP/RUS_CLIN/data/NewFromJay/genetic_diversity/pi_pop.txt",h=F)
pi<-data.frame(t(pi))
crd<-read.table("/Users/piyalkaru/Desktop/UPP/RUS_CLIN/data/NewFromJay/coords_w_hyb_and_gbif_oct28.txt",h=T)
colnames(pi)<-c("pop","pi")
pi$pi<-as.numeric(pi$pi)*0.02604969*2.72751
tm<-crd[crd$Source%in%pi$pop,]
pi<-cbind(tm[,1:2],pi)
rownames(pi)<-pi$pop
colnames(pi)<-c("lon","lat","pop","pi")


library(terra)
wm<-vect("/Users/piyalkaru/Desktop/UPP/Data/maps/TDWG/level3/level3.shp")
papo<-vect("/Users/piyalkaru/Desktop/UPP/RUS_CLIN/out/maps/PAandPO_combined_map.shp")
rng<-ext(0,100,25,75)
# check populations with pi
plot(wm,border="grey85",col="grey99",ext=rng)#,main=paste0("RONA ",nn),mar=c(0, 1.5, 0, 9.1)
points(hi[,3:4])
points(pi[,1:2],pch=19, cex=.5,col=2)
text(pi[,1:2],labels=pi$pop)

#missing pops in hybrid index
setdiff(pi$pop,hi$Population) #"BER"  "FI_2" "PUT"  "YAR"

#sort pi according to hi
pi.n<-pi[match(hi$Population,pi$pop),]
plot(pi.n$pi~hi$hypop) # no visual singificance

pi.hi.lm<-lm(pi.n$pi~hi$hypop)
plot(fitted(pi.hi.lm))
vegan::RsquareAdj(pi.hi.lm)

plot(pi.hi.lm)

cor.test(x=hi$hypop,y=pi.n$pi)
# Pearson's product-moment correlation
#
# data:  hi$hypop and pi.n$pi
# t = -3.7198, df = 49, p-value = 0.0005134
# alternative hypothesis: true correlation is not equal to 0
# 95 percent confidence interval:
#  -0.6595517 -0.2224449
# sample estimates:
#        cor
# -0.4692618




#### plotting on extrapolated map on MS/hybrid server

library(terra)

# --------- functions -------------------
rast_index<-function(indx,geom=c("lon","lat"),resolution=1,crs="+proj=longlat +datum=WGS84",extent=1,field=""){
  pts <- vect(indx, geom=geom, crs=crs)
  r<-rast()
  ext(r)<-ext(pts)
  res(r)<-resolution
  r<-extend(r,ext(r)+(extent*resolution))
  pir<-rasterize(pts,r,field=field)
}


dup_mean<-function(ind.rast, indx){
  pt<-indx[,c("lon","lat")]
  ll<-cbind(cellFromXY(ind.rast,pt),indx)
  dp<-unique(ll[duplicated(ll[,1]),1])
  if(length(dp)>0){
    wodp<-ll[!duplicated(ll[,1]),]
    for(i in seq_along(dp)){
      wodp[wodp[,1]==dp[i],4]<-mean(ll[ll[,1]==dp[i],4])
    }
  } else {
    wodp<-indx
  }
  return(wodp[,2:4])
}
#----------------------------------------
wm<-vect("/home/pkaru/PIYAL/myDat/msc/maps/level3/level3.shp")
papo<-vect("/home/pkaru/PIYAL/myDat/RusClin/maps/PAandPO_combined_map.shp")

fl<-"/home/pkaru/PIYAL/myDat/RusClin/hyb_ind/hybrid_pop.txt"
crd<-read.table("/home/pkaru/PIYAL/myDat/RusClin/niche/coords_w_hyb_and_gbif_oct28.txt",h=T)

for(k in seq_along(fl)){
  pi<-read.table(fl,h=T)
  pi.n<-pi

  tm<-crd[crd$Source%in%rownames(pi),]
  pi<-cbind(tm[,1:2],pi)
  rownames(pi)<-rownames(pi.n)
  colnames(pi)[1:2]<-c("lon","lat")

  pr<-rast_index(pi,resolution = .25,extent=20,field = "weighted")
  wo<-dup_mean(pr,pi)
  pr2<-rast_index(wo,resolution = .25,extent=20,field = "weighted")

  ### interpolate (fill gaps) with nearest neighbor sliding window ######
  mt<-matrix(values(pr2),nrow = dim(pr2)[1],ncol = dim(pr2)[2],byrow = T)
  wind<-50
  width<-3
  for(i in 1:wind){
    ## progress bar--------
    pb <- txtProgressBar(min = 0, max = wind, style = 3, width = 50, char = "=")
    setTxtProgressBar(pb, i)
    ##---------------------
    ## rows
    ht<-apply(mt,1,function(x){
      mps<-NULL
      mpsf<-NULL
      for(j in 1:length(x)){
        #left
        if(j+width<=length(x)){
          if(is.na(x[j])){
            mps[j]<-max(x[j:j+1],na.rm = T)
          } else {mps[j]<-mean(x[j:(j+width)],na.rm=T)}
        }else{
          if(is.na(x[j])){
            mps[j]<-max(x[j:j-1],na.rm = T)
          } else {mps[j]<-mean(x[j:(j-width)],na.rm=T)}
        }
        #right
        if(j-width>0){
          if(is.na(x[j])){
            mpsf[j]<-max(x[j:j-1],na.rm = T)
          } else {mpsf[j]<-mean(x[j:(j-width)],na.rm=T)}
        }else{
          if(is.na(x[j])){
            mpsf[j]<-max(x[j:j+1],na.rm = T)
          } else {mpsf[j]<-mean(x[j:(j+width)],na.rm=T)}
        }

        mps[is.infinite(mps)]<-NA
        mpsf[is.infinite(mpsf)]<-NA

        out<-NULL
        for(k in seq_along(mps)){
          out[k]<-mean(c(mps[k],mpsf[k]),na.rm=T)
        }
      }
      return(out)
    })

    ## columns
    vt<-apply(mt,2,function(x){
      mps<-NULL
      mpsf<-NULL
      for(j in 1:length(x)){
        #left
        if(j+width<length(x)){
          if(is.na(x[j])){
            mps[j]<-max(x[j:j+1],na.rm = T)
          } else {mps[j]<-mean(x[j:(j+width)],na.rm=T)}
        }else{
          if(is.na(x[j])){
            mps[j]<-max(x[j:j-1],na.rm = T)
          } else {mps[j]<-mean(x[j:(j-width)],na.rm=T)}
        }
        #right
        if(j-width>0){
          if(is.na(x[j])){
            mpsf[j]<-max(x[j:j-1],na.rm = T)
          } else {mpsf[j]<-mean(x[j:(j-width)],na.rm=T)}
        }else{
          if(is.na(x[j])){
            mpsf[j]<-max(x[j:j+1],na.rm = T)
          } else {mpsf[j]<-mean(x[j:(j+width)],na.rm=T)}
        }

        mps[is.infinite(mps)]<-NA
        mpsf[is.infinite(mpsf)]<-NA

        out<-NULL
        for(k in seq_along(mps)){
          out[k]<-mean(c(mps[k],mpsf[k]),na.rm=T)
        }
      }
      return(out)
    })

    ## mean matrices
    X<-list(t(ht),vt)
    Y<-do.call(cbind,X)
    Y<-array(Y,dim = c(dim(X[[1]]),length(X)))
    mt<-apply(Y,c(1,2),mean,na.rm=T)
    mt[is.nan(mt)]<-NA
  }
  close(pb)

  saveRDS(mt,paste0("/home/pkaru/PIYAL/myDat/RusClin/RONA/out/PA_PO_wgRONA_extrapl_mat_",substr(basename(fl[k]),9,17),"_",substr(Sys.time(),1,10),".rds"))
  ## raster value set
  epr<-pr2
  values(epr)<-mt
  epr<-mask(epr,papo)
  writeRaster(epr,paste0("/home/pkaru/PIYAL/myDat/RusClin/RONA/out/PA_PO_wgRONA_extrapl_",substr(basename(fl[k]),9,17),"_",substr(Sys.time(),1,10),".tif"))
}





